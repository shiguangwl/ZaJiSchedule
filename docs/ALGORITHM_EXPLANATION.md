# 算法详解

## 📋 目录

- [概述](#概述)
- [滚动窗口算法](#滚动窗口算法)
- [配额计算算法](#配额计算算法)
- [安全限制算法](#安全限制算法)
- [完整示例](#完整示例)
- [边界情况处理](#边界情况处理)

---

## 概述

本系统使用**滚动窗口配额管理算法**来确保 CPU 使用率不超过限制。

### 核心思想

1. **滚动窗口**：固定窗口开始时间（如每天00:00），持续监控窗口内的平均 CPU 使用率
2. **配额管理**：将 CPU 使用视为"配额"，跟踪已用和剩余
3. **最低负载预留**：优先保证剩余时间的最低负载配额
4. **动态调整**：剩余配额动态分配，safe_limit = min_load + 动态部分

### 关键概念

- **窗口时长**：监控的时间范围（如 24 小时）
- **窗口开始时间**：固定的窗口开始时间（如 00:00，可配置）
- **平均限制**：窗口内的平均 CPU 不能超过的值（如 30%）
- **最低负载**：系统保证的最低运行负载（如 10%）
- **配额**：用"百分比·分钟"作为单位，表示 CPU 使用量
- **滚动**：窗口每天固定时间重置，确保不会超限

---

## 滚动窗口算法

### 滑动窗口 vs 滚动窗口

#### 滑动窗口（旧版本，已废弃）

```
时间轴: ─────────────────────────────────────────────►
        -24h    -18h    -12h    -6h     现在
        ├───────┼───────┼───────┼───────┤
        │◄──────── 滑动窗口 ────────────►│

任意时刻: 现在
窗口: [现在-24h, 现在]
问题: 窗口持续移动，可能导致配额分配不当而超限
```

#### 滚动窗口（当前版本）

```
时间轴: ─────────────────────────────────────────────►
        00:00   06:00   12:00   18:00   24:00
        ├───────┼───────┼───────┼───────┤
        │◄──────── 滚动窗口 ────────────►│

窗口开始: 00:00 (可配置)
窗口结束: 24:00
窗口: [00:00, 24:00]
优点: 窗口固定，每天重置，绝对保证不超限
```

### 实现

```python
def _get_current_window_bounds(self) -> tuple[datetime, datetime]:
    """获取当前滚动窗口的开始和结束时间"""
    now = datetime.now()
    window_start_hour = self.config.window_start_hour  # 默认 0
    window_hours = self.config.rolling_window_hours    # 默认 24

    # 计算窗口开始时间
    window_start = now.replace(hour=window_start_hour, minute=0, second=0, microsecond=0)

    # 如果当前时间在窗口开始时间之前，窗口应该是前一天的
    if now < window_start:
        window_start = window_start - timedelta(days=1)

    # 计算窗口结束时间
    window_end = window_start + timedelta(hours=window_hours)

    return window_start, window_end
```

---

## 配额计算算法

### 配额的概念

**配额** = CPU 使用率 × 时间

**单位**：百分比·分钟 (%·min)

**示例**：
- 30% CPU 运行 60 分钟 = 1800 %·min
- 60% CPU 运行 30 分钟 = 1800 %·min
- 15% CPU 运行 120 分钟 = 1800 %·min

### 总配额

**定义**：窗口时长内允许使用的最大配额

**公式**：
```
总配额 = 平均限制 × 窗口时长（分钟）
```

**示例**：
```
平均限制 = 30%
窗口时长 = 24 小时 = 1440 分钟
总配额 = 30% × 1440min = 43200 %·min
```

**含义**：
- 24 小时内，总共可以使用 43200 %·min 的 CPU
- 相当于：
  - 30% CPU 运行 1440 分钟（24 小时），或
  - 60% CPU 运行 720 分钟（12 小时），或
  - 90% CPU 运行 480 分钟（8 小时）

### 已用配额

**定义**：实际已经使用的配额

**公式**：
```
已用配额 = 平均 CPU × 实际运行时长（分钟）
```

**关键**：使用**实际运行时长**，而不是窗口时长！

**示例**：
```
运行 60 分钟:
  平均 CPU = 36.5%
  实际运行时长 = 60 分钟
  已用配额 = 36.5% × 60min = 2190 %·min

运行 720 分钟:
  平均 CPU = 35%
  实际运行时长 = 720 分钟
  已用配额 = 35% × 720min = 25200 %·min
```

### 剩余配额

**定义**：还可以使用的配额

**公式**：
```
剩余配额 = 总配额 - 已用配额
```

**示例**：
```
总配额 = 43200 %·min
已用配额 = 2190 %·min
剩余配额 = 43200 - 2190 = 41010 %·min
```

**含义**：
- 正数：还有余量，未超限
- 负数：已超限，需要降低 CPU 使用

### 实际运行时长

**定义**：从第一个数据点到现在的时间

**公式**：
```
实际运行时长（分钟） = (现在 - 第一个数据点的时间) / 60
```

**示例**：
```
第一个数据点: 2025-10-22 16:05:27
现在: 2025-10-22 17:08:39
实际运行时长 = 63 分钟 (1.05 小时)
```

**注意**：
- 如果运行时长 < 窗口时长，使用实际运行时长
- 如果运行时长 >= 窗口时长，窗口已满，使用窗口时长

---

## 安全限制算法

### 核心逻辑

**定义**：基于剩余配额和最低负载预留计算安全限制

**公式**：
```
# 1. 计算未来需要的最低负载配额
future_min_quota = min_load × remaining_minutes

# 2. 判断剩余配额是否充足
if remaining_quota <= 0:
    safe_limit = min_load  # 配额耗尽，使用最低负载
elif remaining_quota < future_min_quota:
    safe_limit = min_load  # 配额不足，使用最低负载
else:
    # 配额充足，可以分配动态部分
    dynamic_quota = remaining_quota - future_min_quota
    dynamic_limit = (dynamic_quota / remaining_minutes) × safety_factor
    safe_limit = min_load + dynamic_limit

# 3. 限制在 [min_load, max_load] 范围内
safe_limit = max(min_load, min(max_load, safe_limit))
```

**示例**：
```
min_load = 10%
max_load = 90%
safety_factor = 0.9
remaining_quota = 41010 %·min
remaining_minutes = 1380 min

future_min_quota = 10% × 1380 = 13800 %·min
dynamic_quota = 41010 - 13800 = 27210 %·min
dynamic_limit = (27210 / 1380) × 0.9 = 17.7%
safe_limit = 10% + 17.7% = 27.7%
```

**含义**：
- 优先保证剩余时间的最低负载（10%）
- 剩余配额动态分配，应用安全系数（0.9）
- 最终限制 = 最低负载 + 动态部分

### 边界处理

#### 情况 1：配额充足

```python
if remaining_quota >= future_min_quota:
    dynamic_quota = remaining_quota - future_min_quota
    dynamic_limit = (dynamic_quota / remaining_minutes) × safety_factor
    safe_limit = min_load + dynamic_limit
```

**说明**：
- 剩余配额充足，可以分配动态部分
- 应用安全系数，留出余量

#### 情况 2：配额不足

```python
elif remaining_quota < future_min_quota:
    safe_limit = min_load
    logger.error("配额管理失败！剩余配额不足，但仍使用最低负载以保证系统运行")
```

**说明**：
- 剩余配额不足以支持最低负载
- 仍使用最低负载，发出 ERROR 警告
- 预计将超限，需要调整安全系数

#### 情况 3：配额耗尽

```python
if remaining_quota <= 0:
    safe_limit = min_load
    logger.error("配额管理失败！剩余配额耗尽，但仍使用最低负载以保证系统运行")
```

**说明**：
- 剩余配额耗尽
- 仍使用最低负载，发出 ERROR 警告
- 预计将超限，需要调整安全系数

---

## 完整示例

### 场景设置

**配置**：
- 窗口时长：24 小时
- 平均限制：30%
- 安全系数：0.9
- 采集间隔：5 秒

### 时间线

#### T = 0min（启动）

```
数据点: 0
实际运行时长: 0min
平均 CPU: 0%

总配额: 30% × 1440min = 43200 %·min
已用配额: 0% × 0min = 0 %·min
剩余配额: 43200 - 0 = 43200 %·min
剩余时间: 1440 - 0 = 1440min
目标 CPU: 43200 / 1440 = 30%
安全限制: 30% × 0.9 = 27%
```

#### T = 60min（1小时）

```
数据点: 720 (60min / 5s)
实际运行时长: 60min
平均 CPU: 36.5%

总配额: 43200 %·min
已用配额: 36.5% × 60min = 2190 %·min
剩余配额: 43200 - 2190 = 41010 %·min
剩余时间: 1440 - 60 = 1380min
目标 CPU: 41010 / 1380 = 29.7%
安全限制: 29.7% × 0.9 = 26.7%
```

**状态**：
- ✅ 未超限（剩余配额 > 0）
- 📊 建议：未来保持在 26.7% 以下

#### T = 720min（12小时）

```
数据点: 8640
实际运行时长: 720min
平均 CPU: 35%

总配额: 43200 %·min
已用配额: 35% × 720min = 25200 %·min
剩余配额: 43200 - 25200 = 18000 %·min
剩余时间: 1440 - 720 = 720min
目标 CPU: 18000 / 720 = 25%
安全限制: 25% × 0.9 = 22.5%
```

**状态**：
- ✅ 未超限
- 📊 建议：未来保持在 22.5% 以下
- ⚠️ 注意：安全限制降低了

#### T = 1440min（24小时，窗口已满）

```
数据点: 17280
实际运行时长: 1440min
平均 CPU: 28%

总配额: 43200 %·min
已用配额: 28% × 1440min = 40320 %·min
剩余配额: 43200 - 40320 = 2880 %·min
剩余时间: 1440 - 1440 = 0min
目标 CPU: 30% (剩余配额 > 0)
安全限制: 30% × 0.9 = 27%
```

**状态**：
- ✅ 未超限
- 📊 建议：可以继续保持在 27% 以下
- 🎉 成功：24 小时平均 28% < 30%

---

## 边界情况处理

### 1. 数据不足

**情况**：刚启动，数据点 < 10

**处理**：
```python
if len(metrics) < 10:
    return {
        "total_quota": avg_limit * window_hours,
        "used_quota": 0.0,
        "remaining_quota": avg_limit * window_hours,
        "avg_cpu_percent": 0.0,
        "target_cpu_percent": avg_limit,
    }
```

### 2. 剩余配额为负

**情况**：已超限

**处理**：
```python
if remaining_quota < 0:
    # 计算需要降低的幅度
    over_usage = abs(remaining_quota)

    if remaining_hours > 0:
        # 还有时间，计算需要降低到多少
        target_cpu = max(0, (total_quota - used_quota) / remaining_hours)
    else:
        # 没有时间了，停止使用
        target_cpu = 0
```

### 3. 目标 CPU 超过 100%

**情况**：剩余配额很大

**处理**：
```python
target_cpu = max(0, min(100, remaining_quota / remaining_hours))
```

### 4. 窗口已满

**情况**：运行时长 >= 窗口时长

**处理**：
```python
# 使用滚动窗口，自动丢弃旧数据
metrics = db.get_metrics_in_window(window_hours)

# 计算平均 CPU（只包含窗口内的数据）
avg_cpu = sum(m["cpu_percent"] for m in metrics) / len(metrics)
```

---

## 数学证明

### 定理：如果遵循安全限制，则不会超限

**假设**：
- 窗口时长：T 分钟
- 平均限制：L%
- 已运行时长：t 分钟（t < T）
- 已用配额：U %·min
- 剩余时间：R = T - t 分钟
- 目标 CPU：C = (L×T - U) / R

**证明**：
```
如果未来 R 分钟保持在 C%：

未来配额 = C × R
         = [(L×T - U) / R] × R
         = L×T - U

总配额 = U + 未来配额
       = U + (L×T - U)
       = L×T

平均 CPU = 总配额 / T
         = (L×T) / T
         = L%

∴ 平均 CPU = L%，刚好等于限制
```

**结论**：
- 如果遵循目标 CPU，平均 CPU 将等于限制
- 应用安全系数后，平均 CPU 将低于限制
- 因此不会超限 ✅

---

## 总结

### 算法优势

1. **精确**：基于数学公式，精确计算
2. **动态**：根据历史数据动态调整
3. **安全**：应用安全系数，留出余量
4. **实时**：滚动窗口，实时反映最近状态

### 关键要点

1. **使用实际运行时长**：不要假设整个窗口都在运行
2. **滚动窗口**：窗口随时间移动，不是固定的
3. **配额单位**：使用"百分比·分钟"作为单位（更精细的控制）
4. **安全系数**：留出余量，应对突发负载

### 适用场景

- ✅ 共享主机 CPU 限制
- ✅ 云服务器 CPU 配额
- ✅ 容器 CPU 限制
- ✅ 任何需要控制平均 CPU 使用率的场景
