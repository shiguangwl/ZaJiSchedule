# 算法详解

## 📋 目录

- [概述](#概述)
- [滚动窗口算法](#滚动窗口算法)
- [配额计算算法](#配额计算算法)
- [安全限制算法](#安全限制算法)
- [完整示例](#完整示例)
- [边界情况处理](#边界情况处理)

---

## 概述

本系统使用**滚动窗口配额管理算法**来确保 CPU 使用率不超过限制。

### 核心思想

1. **滚动窗口**：持续监控过去 N 小时的平均 CPU 使用率
2. **配额管理**：将 CPU 使用视为"配额"，跟踪已用和剩余
3. **动态调整**：根据剩余配额动态调整未来的 CPU 限制

### 关键概念

- **窗口时长**：监控的时间范围（如 24 小时）
- **平均限制**：窗口内的平均 CPU 不能超过的值（如 30%）
- **配额**：用"百分比·小时"作为单位，表示 CPU 使用量
- **滚动**：窗口随时间移动，始终是"现在 - N 小时"到"现在"

---

## 滚动窗口算法

### 固定窗口 vs 滚动窗口

#### 固定窗口（错误）

```
时间轴: ─────────────────────────────────────────────►
        0h      6h      12h     18h     24h
        ├───────┼───────┼───────┼───────┤
        │◄──────── 固定窗口 ────────────►│

启动时间: 0h
窗口: [0h, 24h]
问题: 窗口不移动，24小时后需要重置
```

#### 滚动窗口（正确）

```
时间轴: ─────────────────────────────────────────────►
        -24h    -18h    -12h    -6h     现在
        ├───────┼───────┼───────┼───────┤
        │◄──────── 滚动窗口 ────────────►│

任意时刻: 现在
窗口: [现在-24h, 现在]
优点: 窗口持续移动，实时反映最近24小时
```

### 实现

```python
def get_metrics_in_window(hours: int) -> list:
    """获取滚动窗口内的数据"""
    start_time = datetime.now() - timedelta(hours=hours)
    end_time = datetime.now()

    # 查询 [start_time, end_time] 范围内的数据
    return db.query(
        "SELECT * FROM metrics_history "
        "WHERE timestamp >= ? AND timestamp <= ?",
        (start_time, end_time)
    )
```

---

## 配额计算算法

### 配额的概念

**配额** = CPU 使用率 × 时间

**单位**：百分比·分钟 (%·min)

**示例**：
- 30% CPU 运行 60 分钟 = 1800 %·min
- 60% CPU 运行 30 分钟 = 1800 %·min
- 15% CPU 运行 120 分钟 = 1800 %·min

### 总配额

**定义**：窗口时长内允许使用的最大配额

**公式**：
```
总配额 = 平均限制 × 窗口时长（分钟）
```

**示例**：
```
平均限制 = 30%
窗口时长 = 24 小时 = 1440 分钟
总配额 = 30% × 1440min = 43200 %·min
```

**含义**：
- 24 小时内，总共可以使用 43200 %·min 的 CPU
- 相当于：
  - 30% CPU 运行 1440 分钟（24 小时），或
  - 60% CPU 运行 720 分钟（12 小时），或
  - 90% CPU 运行 480 分钟（8 小时）

### 已用配额

**定义**：实际已经使用的配额

**公式**：
```
已用配额 = 平均 CPU × 实际运行时长（分钟）
```

**关键**：使用**实际运行时长**，而不是窗口时长！

**示例**：
```
运行 60 分钟:
  平均 CPU = 36.5%
  实际运行时长 = 60 分钟
  已用配额 = 36.5% × 60min = 2190 %·min

运行 720 分钟:
  平均 CPU = 35%
  实际运行时长 = 720 分钟
  已用配额 = 35% × 720min = 25200 %·min
```

### 剩余配额

**定义**：还可以使用的配额

**公式**：
```
剩余配额 = 总配额 - 已用配额
```

**示例**：
```
总配额 = 43200 %·min
已用配额 = 2190 %·min
剩余配额 = 43200 - 2190 = 41010 %·min
```

**含义**：
- 正数：还有余量，未超限
- 负数：已超限，需要降低 CPU 使用

### 实际运行时长

**定义**：从第一个数据点到现在的时间

**公式**：
```
实际运行时长（分钟） = (现在 - 第一个数据点的时间) / 60
```

**示例**：
```
第一个数据点: 2025-10-22 16:05:27
现在: 2025-10-22 17:08:39
实际运行时长 = 63 分钟 (1.05 小时)
```

**注意**：
- 如果运行时长 < 窗口时长，使用实际运行时长
- 如果运行时长 >= 窗口时长，窗口已满，使用窗口时长

---

## 安全限制算法

### 目标 CPU

**定义**：未来应该保持的 CPU 使用率

**公式**：
```
剩余时间（分钟） = 窗口时长（分钟） - 实际运行时长（分钟）
目标 CPU = 剩余配额 / 剩余时间
```

**示例**：
```
剩余配额 = 41010 %·min
剩余时间 = 1440 - 60 = 1380 分钟
目标 CPU = 41010 / 1380 = 29.7%
```

**含义**：
- 未来 1380 分钟（23 小时）内，如果保持在 29.7% 以下
- 24 小时平均 CPU 将不超过 30%

### 安全限制

**定义**：应用安全系数后的限制

**公式**：
```
安全限制 = 目标 CPU × 安全系数
```

**示例**：
```
目标 CPU = 29.7%
安全系数 = 0.9
安全限制 = 29.7% × 0.9 = 26.7%
```

**原因**：
- 留出 10% 的余量
- 应对突发负载
- 避免因短时间波动而超限

### 边界处理

#### 情况 1：剩余时间 > 0

```python
if remaining_hours > 0:
    target_cpu = max(0, min(100, remaining_quota / remaining_hours))
```

**说明**：
- 正常计算目标 CPU
- 限制在 [0, 100] 范围内

#### 情况 2：剩余时间 = 0（窗口已满）

```python
else:
    if remaining_quota >= 0:
        target_cpu = avg_limit  # 未超限，保持限制
    else:
        target_cpu = 0  # 已超限，停止使用
```

**说明**：
- 窗口已满，无剩余时间
- 如果未超限，可以继续保持在限制内
- 如果已超限，应该停止使用 CPU

---

## 完整示例

### 场景设置

**配置**：
- 窗口时长：24 小时
- 平均限制：30%
- 安全系数：0.9
- 采集间隔：5 秒

### 时间线

#### T = 0min（启动）

```
数据点: 0
实际运行时长: 0min
平均 CPU: 0%

总配额: 30% × 1440min = 43200 %·min
已用配额: 0% × 0min = 0 %·min
剩余配额: 43200 - 0 = 43200 %·min
剩余时间: 1440 - 0 = 1440min
目标 CPU: 43200 / 1440 = 30%
安全限制: 30% × 0.9 = 27%
```

#### T = 60min（1小时）

```
数据点: 720 (60min / 5s)
实际运行时长: 60min
平均 CPU: 36.5%

总配额: 43200 %·min
已用配额: 36.5% × 60min = 2190 %·min
剩余配额: 43200 - 2190 = 41010 %·min
剩余时间: 1440 - 60 = 1380min
目标 CPU: 41010 / 1380 = 29.7%
安全限制: 29.7% × 0.9 = 26.7%
```

**状态**：
- ✅ 未超限（剩余配额 > 0）
- 📊 建议：未来保持在 26.7% 以下

#### T = 720min（12小时）

```
数据点: 8640
实际运行时长: 720min
平均 CPU: 35%

总配额: 43200 %·min
已用配额: 35% × 720min = 25200 %·min
剩余配额: 43200 - 25200 = 18000 %·min
剩余时间: 1440 - 720 = 720min
目标 CPU: 18000 / 720 = 25%
安全限制: 25% × 0.9 = 22.5%
```

**状态**：
- ✅ 未超限
- 📊 建议：未来保持在 22.5% 以下
- ⚠️ 注意：安全限制降低了

#### T = 1440min（24小时，窗口已满）

```
数据点: 17280
实际运行时长: 1440min
平均 CPU: 28%

总配额: 43200 %·min
已用配额: 28% × 1440min = 40320 %·min
剩余配额: 43200 - 40320 = 2880 %·min
剩余时间: 1440 - 1440 = 0min
目标 CPU: 30% (剩余配额 > 0)
安全限制: 30% × 0.9 = 27%
```

**状态**：
- ✅ 未超限
- 📊 建议：可以继续保持在 27% 以下
- 🎉 成功：24 小时平均 28% < 30%

---

## 边界情况处理

### 1. 数据不足

**情况**：刚启动，数据点 < 10

**处理**：
```python
if len(metrics) < 10:
    return {
        "total_quota": avg_limit * window_hours,
        "used_quota": 0.0,
        "remaining_quota": avg_limit * window_hours,
        "avg_cpu_percent": 0.0,
        "target_cpu_percent": avg_limit,
    }
```

### 2. 剩余配额为负

**情况**：已超限

**处理**：
```python
if remaining_quota < 0:
    # 计算需要降低的幅度
    over_usage = abs(remaining_quota)

    if remaining_hours > 0:
        # 还有时间，计算需要降低到多少
        target_cpu = max(0, (total_quota - used_quota) / remaining_hours)
    else:
        # 没有时间了，停止使用
        target_cpu = 0
```

### 3. 目标 CPU 超过 100%

**情况**：剩余配额很大

**处理**：
```python
target_cpu = max(0, min(100, remaining_quota / remaining_hours))
```

### 4. 窗口已满

**情况**：运行时长 >= 窗口时长

**处理**：
```python
# 使用滚动窗口，自动丢弃旧数据
metrics = db.get_metrics_in_window(window_hours)

# 计算平均 CPU（只包含窗口内的数据）
avg_cpu = sum(m["cpu_percent"] for m in metrics) / len(metrics)
```

---

## 数学证明

### 定理：如果遵循安全限制，则不会超限

**假设**：
- 窗口时长：T 分钟
- 平均限制：L%
- 已运行时长：t 分钟（t < T）
- 已用配额：U %·min
- 剩余时间：R = T - t 分钟
- 目标 CPU：C = (L×T - U) / R

**证明**：
```
如果未来 R 分钟保持在 C%：

未来配额 = C × R
         = [(L×T - U) / R] × R
         = L×T - U

总配额 = U + 未来配额
       = U + (L×T - U)
       = L×T

平均 CPU = 总配额 / T
         = (L×T) / T
         = L%

∴ 平均 CPU = L%，刚好等于限制
```

**结论**：
- 如果遵循目标 CPU，平均 CPU 将等于限制
- 应用安全系数后，平均 CPU 将低于限制
- 因此不会超限 ✅

---

## 总结

### 算法优势

1. **精确**：基于数学公式，精确计算
2. **动态**：根据历史数据动态调整
3. **安全**：应用安全系数，留出余量
4. **实时**：滚动窗口，实时反映最近状态

### 关键要点

1. **使用实际运行时长**：不要假设整个窗口都在运行
2. **滚动窗口**：窗口随时间移动，不是固定的
3. **配额单位**：使用"百分比·分钟"作为单位（更精细的控制）
4. **安全系数**：留出余量，应对突发负载

### 适用场景

- ✅ 共享主机 CPU 限制
- ✅ 云服务器 CPU 配额
- ✅ 容器 CPU 限制
- ✅ 任何需要控制平均 CPU 使用率的场景
